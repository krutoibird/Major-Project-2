"""
Our reason for breaking every part of the game into multiple parts is
so we can edit any specific part of the game without having to look
through hundreds of lines of code or having to edit other parts so
the code functions properly. OOP for the win.
"""
import pygame
pygame.init()
# Display variables
SCREEN_WIDTH = 720
SCREEN_HEIGHT = 360
TILE_SIZE = 40
# Every move is calculated by tile not by pixel
GRID_WIDTH = SCREEN_WIDTH // TILE_SIZE
GRID_HEIGHT = SCREEN_HEIGHT // TILE_SIZE
FPS = 60

"""
Game class containing:
Screen setup (Img loading and resizing)
Other objects in the game defined as variables (Worm,Apples,Level)
Basic movement handling (UP,DOWN,LEFT,RIGHT)
Screen updating function
Main game loop
"""

class Game:

    # VARIABLES DEFINED FOR GAME CLASS

    def __init__(self):
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Bullshit I've been coding for hours now")
        # Background img loading and scaling
        self.background_img = pygame.transform.scale(
            pygame.image.load("Images/Sky.png").convert(),(SCREEN_WIDTH, SCREEN_HEIGHT))
        # Block img loading and scaling
        self.block_img = pygame.transform.scale(
            pygame.image.load("Images/Terre.png").convert(),(TILE_SIZE, TILE_SIZE))
        # Apple img loading and scaling
        self.apple_img = pygame.transform.scale(
            pygame.image.load("Images/Apple.png").convert_alpha(),(TILE_SIZE, TILE_SIZE))
        # Worm_head img loading and scaling
        self.head_img = pygame.transform.scale(
            pygame.image.load("Images/wormhead.png").convert_alpha(),(TILE_SIZE, TILE_SIZE))
        # Worm_body img loading and scaling
        self.body_img = pygame.transform.scale(
            pygame.image.load("Images/wormbody.png").convert_alpha(),(TILE_SIZE, TILE_SIZE))

        # Using objects to define other classes as variables in game class
        self.level = Level(self)
        self.worm = Worm(self)
        # Defining apple positions in apple_y and numbers in self.apples
        apple_y = GRID_HEIGHT - 2
        self.apples = [Apple(self, (8, apple_y)),Apple(self, (12, apple_y))]
        # Running is just game_active/Clock is just for modifiable refresh rate
        self.clock = pygame.time.Clock()
        self.running = True

    # Function for movement handling
    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    self.running = False

                if event.key in (pygame.K_w, pygame.K_UP):
                    self.worm.try_move((0, -1))
                elif event.key in (pygame.K_s, pygame.K_DOWN):
                    self.worm.try_move((0, 1))
                elif event.key in (pygame.K_a, pygame.K_LEFT):
                    self.worm.try_move((-1, 0))
                elif event.key in (pygame.K_d, pygame.K_RIGHT):
                    self.worm.try_move((1, 0))

    # Function for displaying everything
    def draw(self):
        # Background blitting
        self.screen.blit(self.background_img, (0, 0))
        # Ground blitting
        self.level.draw()
        # Apples blitting
        for apple in self.apples:
            apple.draw()
        # Worm blitting
        self.worm.draw()
        pygame.display.update()

    # Main game loop
    def run(self):
        while self.running:
            # Handling movement(up,down,left,right)
            self.handle_events()
            # Gravity pressure applied on worm
            self.worm.apply_gravity()
            # update display continuously
            self.draw()
            # Took line 46 and set up refresh rate per second
            self.clock.tick(FPS)

"""
Level class containing:
Block setup
Block testing
Block drawing on screen
"""

class Level:

    # VARIABLES FOR BLOCK CLASS
    def __init__(self, game):
        self.game = game
        self.blocks = []
        # Making the last row of the display only blocks for now
        ground_y = GRID_HEIGHT - 1
        # Using tuples to place all the blocks in the last row of the display
        for x in range(GRID_WIDTH):
            self.blocks.append((x, ground_y))

    # Function for the game to process if a tile is a block or if it is not (Eg. if it is worm can't pass through/turn off gravity)
    def is_block(self, tile):
        return tile in self.blocks
    # Function for drawing the blocks onto the screen
    def draw(self):
        for gx, gy in self.blocks:
            # Every block is resized because our layout is tile-oriented
            px = gx * TILE_SIZE
            py = gy * TILE_SIZE
            self.game.screen.blit(self.game.block_img, (px, py))

"""
Apple class containing:
Apple setup
Apple drawing on screen (If apple has not been eaten yet)
"""
class Apple:
    def __init__(self, game, position):
        self.game = game
        self.position = position
        self.active = True  # If apple has not been eaten yet

    def draw(self):
        # If self.active is false, then the function stops there
        if not self.active:
            return
        gx, gy = self.position
        px = gx * TILE_SIZE
        py = gy * TILE_SIZE
        self.game.screen.blit(self.game.apple_img, (px, py))


"""
Worm class containing:
Worm head/body/gravity setup
Worm movement logic 
Worm growth logic
Worm drawing on screen
"""

class Worm:

    # VARIABLES FOR WORM CLASS
    def __init__(self, game):
        self.game = game

        # Initial position when you load the game
        start_x = 3
        start_y = 1
        # Body system setup / Determining initial worm size (3)
        self.segments = [
            (start_x, start_y),
            (start_x - 1, start_y),
            (start_x - 2, start_y)
        ]
        # Direction points where head wants to go, body follows
        self.direction = (1, 0)
        self.grow_amount = 0
        # Counter is to calculate number of frames passed
        self.gravity_counter = 0
        # So every time gravity counter reaches 1 worm falls one tile (gravity_delay)
        self.gravity_delay = 10

    def head(self):
        # Head is always segments[0]
        return self.segments[0]

    # Configure direction of the worm
    def set_direction(self, direction):
        dx, dy = direction
        cdx, cdy = self.direction
        self.direction = direction

    # Moving the worm's head towards its new direction / Its body follows automatically (Look at initialization)
    def try_move(self, direction):
        self.set_direction(direction)
        dx, dy = self.direction

        hx, hy = self.head()
        new_head = (hx + dx, hy + dy)

        if not (0 <= new_head[0] < GRID_WIDTH):
            return
        if not (0 <= new_head[1] < GRID_HEIGHT):
            return

        if self.game.level.is_block(new_head):
            return

        if new_head in self.segments:
            return

        self._move_to(new_head)

    def apply_gravity(self):
        # Gravity logic
        self.gravity_counter += 1
        if self.gravity_counter < self.gravity_delay:
            return
        self.gravity_counter = 0

        supported = False # Why? because the worm spawns in the air (for now)

        for (sx, sy) in self.segments:
            below = (sx, sy + 1)
            # Condition for worm to not go out of frame
            if below[1] >= GRID_HEIGHT:
                supported = True
                break

            # Test if there is a block under the worm
            if self.game.level.is_block(below):
                supported = True
                break
        if supported:
            return
        hx, hy = self.head()
        new_head = (hx, hy + 1) # Gravity brings head downwards

        # Worm can't go inside it's own body
        if new_head in self.segments:
            return
        self._move_to(new_head)

    def _move_to(self, new_head):
        self.segments.insert(0, new_head)

        if self.grow_amount > 0:
            self.grow_amount -= 1
        else:
            self.segments.pop()

        # Function for apple triggering growth and disappearing on overlap (When apple/head == same position)
        for apple in self.game.apples:
            if apple.active and apple.position == new_head:
                apple.active = False
                self.grow(1)
    # Keeping track of worm's growth
    def grow(self, amount):
        self.grow_amount += amount

    # Worm drawing onto the screen / Fitting the coordinates to the tile layout
    def draw(self):
        hx, hy = self.segments[0]
        self.game.screen.blit(self.game.head_img, (hx * TILE_SIZE, hy * TILE_SIZE))

        for gx, gy in self.segments[1:]:
            px = gx * TILE_SIZE
            py = gy * TILE_SIZE
            self.game.screen.blit(self.game.body_img, (px, py))


# Running the game
game = Game()
game.run()
pygame.quit()
